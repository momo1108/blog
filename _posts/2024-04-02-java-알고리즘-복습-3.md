---
layout: post
title: JAVA 알고리즘 복습 3
date: '2024-04-02 14:24:07 +0900'
category: [JAVA, 알고리즘]
tags: [java,알고리즘]
math: true
---

# 서론
이 포스트는 코딩 테스트를 위해 수강했던 패스트캠퍼스의 알고리즘 강의 **한 번에 끝내는 코딩테스트 369 Java편 초격차 패키지 Online.** 의 류호석 강사의 강의를 복습하며 정리한 내용입니다.

---

## 알고리즘 분류
### 위상 정렬(Topological Sort)
**위상**을 기준으로 정렬한다는 뜻.

**위상**이 무엇인지 알기 위해서는 먼저 그래프 중에 DAG(Directed Acyclic Graph)에 대해서 알아야 한다.

#### DAG(Directed Acyclic Graph)
![dag](/assets/img/captures/1_dag.png){: width='450' .normal }

- Directed : 간선에 방향성이 존재한다.
- Acyclic : 사이클이 없다.
- Graph : 정점(V) + 간선(E) 으로 이루어져있다.

##### 차수(Degree)
방향성이 없는 그래프에서는 정점에 연결된 간선의 수가 곧 차수를 뜻했다.

그러나 방향성이 존재하는 DAG 의 경우, 한 정점으로 들어오는 간선과 다른 정점으로 나가는 간선이 분리가 되므로, **두가지 종류의 차수**를 사용한다.

1. Indegree : 도착지가 자신(정점)인 간선의 개수
2. Outdegree : 자신(정점)으로부터 나가는 간선의 개수

---

#### 정렬 방법
이와 같은 간선, 즉 차수 정보를 사용하여 위상에 맞춰 정렬을 하는데 이러한 방법에는 크게 2가지 아이디어가 있다.

##### 1. Indegree 를 사용한 정렬.
1. 정렬의 시작점으로서 자신에게 들어오는 간선(Indegree)이 없는 정점을 Queue 에 넣는다.<br>
    ![ts](/assets/img/captures/2_ts.png){: width='400' .normal }
2. Queue 의 첫 정점을 빼낸 후 정렬결과에 포함한 후에 outdegree 또한 삭제한다. 그 후 Indegree 가 0인 정점들을 다시 Queue 에 추가한다.<br>
    ![ts](/assets/img/captures/3_ts.png){: width='400' .normal }
3. Queue 가 빌 때 까지 2번의 작업을 계속 반복한다.<br>
    ![ts](/assets/img/captures/4_ts.png){: width='300' .normal }
    ![ts](/assets/img/captures/5_ts.png){: width='300' .normal }
    ![ts](/assets/img/captures/6_ts.png){: width='300' .normal }
    ![ts](/assets/img/captures/7_ts.png){: width='300' .normal }
    ![ts](/assets/img/captures/8_ts.png){: width='300' .normal }
    ![ts](/assets/img/captures/9_ts.png){: width='300' .normal }
    ![ts](/assets/img/captures/10_ts.png){: width='300' .normal }

##### 2. SCC(Strongly Connected Component)
이는 코딩테스트에는 나오지 않는 수준의 아이디어이므로 패스.

---

#### 예시 문제
- [BOJ 2252 - 줄 세우기](https://www.acmicpc.net/problem/2252){: target='_blank' }, [BOJ 2623 - 음악 프로그램](https://www.acmicpc.net/problem/2623){: target='_blank' }, [BOJ 9470 - Strahler 순서](https://www.acmicpc.net/problem/9470){: target='_blank' }, [BOJ 14676 - 영우는 사기꾼?](https://www.acmicpc.net/problem/14676){: target='_blank' }
- [BOJ 1005 - ACM Craft](https://www.acmicpc.net/problem/1005){: target='_blank' }, [BOJ 1516 - 게임 개발](https://www.acmicpc.net/problem/1516){: target='_blank' }, [BOJ 2056 - 작업](https://www.acmicpc.net/problem/2056){: target='_blank' }, [BOJ 2637 - 장난감 조립](https://www.acmicpc.net/problem/2637){: target='_blank' }

---

### 최단 경로(Shortest Path)
#### 최단거리란?
그래프의 시작점에서 다른 지점까지의 최단 거리를 뜻한다.

최단 거리를 구하는 방식은 여러가지가 있다.

|이름|간선 가중치|시작점|도착점|시간 복잡도|
|:--:|:--:|:--:|:--:|:--:|
|**BFS**|1|1개|V(모든 정점)|$O(V + E)$|
|**Dijkstra**|0 이상|1개|V(모든 정점)|$O(Elog{V})$|
|**Floyd-Warshall**|제약 없음|**V(모든 정점)**|V(모든 정점)|$O(V^3)$|
|**Bellman-Ford**|제약 없음|1개|V(모든 정점)|$O(V*E)$|
|**SPFA**|제약 없음|1개|V(모든 정점)|$O(V*E)$|
|**A\***|0 이상|1개|**1**|$O(b^d)$|

위 방식중에서도 코딩 테스트에는 BFS, Dijkstra 알고리즘이 주로 나온다.