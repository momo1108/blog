---
layout: post
title: JAVA 알고리즘 복습 1
date: '2024-03-19 15:11:21 +0900'
category: [JAVA, 알고리즘]
tags: [java,알고리즘]
math: true
---

# 서론
이 포스트는 코딩 테스트를 위해 수강했던 알고리즘 강의 **한 번에 끝내는 코딩테스트 369 Java편 초격차 패키지 Online.** 를 복습하며 정리한 내용입니다.

## 알고리즘
문제를 해결하기 위한 **절차(방법)**이다.

주어진 문제에 맞춰서 **입력**을 넣으면 원하는 **출력**을 얻을 수 있도록 해주는 프로그래밍이다.

문제에 어떤 알고리즘을 사용하느냐에 따라 성능이 차이가 나기 때문에, 문제에 맞는 알고리즘을 사용해야 한다.

### 알고리즘에 좋은 습관은?
#### 문제를 올바른 순서로 이해하자
1. 시간, 메모리 제한 확인하고 문제를 꼼꼼히 읽기
2. 제공되는 정보들과 예제 데이터를 이해
3. 가능한 최대, 최소 정답에 맞는 데이터를 직접 생성

#### 시간 복잡도, 공간 복잡도 계산
문제를 풀기전에 제한시간을 맞출 수 없는 알고리즘의 경우를 제외할 수 있다.

|알고리즘|시간 복잡도|공간 복잡도|
|:--:|:--:|:--:|
|BFS, DFS|O(V+E)|O(V+E)|
|Dijkstra|O(E log E), O(E log V)|O(V+E)|
|Quick Sort|평균 O(N log N), 최대 O(N^2)|O(V)|
|Binary Search|O(N log N)|O(N)|

#### 코드를 함수화해서 효율적으로 구현
같은 코드의 반복은 함수화해서 효율적으로 구현한다.

#### 부분 점수를 챙긴다.
여러 문제의 부분점수를 챙기는 것이 한 문제만 다 푸는것보다 높은 점수를 챙기는 경우가 생긴다.

---

### 완전 탐색(Brute Force)
문제 해결을 위한 모든 경우의 수를 전부 탐색한다.

**단순 for 문 만이 아닌 재귀를 통한 Back Tracking 상황도 해결할 줄 알아야 한다.**

가장 기본적인 접근방식으로, 많은 연습이 필요하다.

**부분점수를 얻기는 좋으나, 시간 복잡도가 높은 편이다.**

#### 완전 탐색의 종류
전체 N 개의 데이터에서 M 개를 고르는 문제의 경우

|중복 \\ 순서|있음|없음|
|:--:|:--:|:--:|
|**허용**|[백준 15651](https://www.acmicpc.net/problem/15651){: target='_blank' }|[백준 15652](https://www.acmicpc.net/problem/15652){: target='_blank' }|
|**제외**|[백준 15649](https://www.acmicpc.net/problem/15649){: target='_blank' }|[백준 15650](https://www.acmicpc.net/problem/15650){: target='_blank' }|

위 문제들의 시간복잡도와 공간복잡도를 계산해보면 다음과 같다.

|중복 \\ 순서|순서 있음|순서 없음|
|:--:|:--:|:--:|
|**중복 허용**|시간복잡도 : <br> $O(N^M) = 7^7 \approx 82$만 <br> 공간복잡도 : $O(M)$|시간복잡도 : <br> $O(N^M) = 8^8 \approx 1677$만 보다 작음 <br> 공간복잡도 : $O(M)$|
|**중복 제외**|시간복잡도 : <br> $O({N \atop M}P) = O(\frac{N!}{(N-M)!})$ <br> $= \frac{8!}{0!} = 40,320$ <br> 공간복잡도 : $O(M)$|시간복잡도 : <br> $O({N \atop M}C) = O(\frac{N!}{M!(N-M)!})$ <br> $= \frac{8!}{4!4!} = 70$ <br> 공간복잡도 : $O(M)$|

#### 예시 문제
[BOJ 14888](https://www.acmicpc.net/problem/14888){: target='_blank' }, [BOJ 9663](https://www.acmicpc.net/problem/9663){: target='_blank' }