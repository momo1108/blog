---
layout: post
title: 컴퓨터 구조 2 - 데이터의 표현
date: '2024-05-03 15:48:47 +0900'
category: [CS, 컴퓨터구조]
tags: [CS,컴퓨터구조]
math: true
---

> **이 포스트는 패스트캠퍼스의 "컴퓨터 공학 전공 필수 올인원 패키지 Online." 강의를 보고 정리한 내용입니다.**
{: .prompt-tip }

# 데이터의 표현
컴퓨터에서 데이터를 표현하는 방법에 대해서 알아보자.

## 단위
디지털 정보의 단위는 지난 포스트의 표에 정리된 단위들을 포함해 다양한 단위들이 있다.

|단위명|범위|
|:--|:--|
|비트(Bit)|0, 1|
|바이트(Byte)|1 byte = 8 bit|
|워드(Word)|기계에 따라 상이. 1 Word = `32 bit` or `64 bit`|
|킬로바이트(KB, KiloByte)|1 KB = 1024 byte = $2^{10}$ byte|
|메가바이트(MB, MegaByte)|1 MB = 1024 Kbyte = $2^{20}$ byte|
|기가바이트(GB, GigaByte)|1 GB = 1024 Mbyte = $2^{30}$ byte|
|테라바이트(TB, TeraByte)|1 TB = 1024 Gbyte = $2^{40}$ byte|

이 외에도 4bit 에 해당하는 nibble 과 한 문자를 나타내는 character, 특정 CPU 에서 취급하는 명령어/데이터의 길이를 나타내는 word 등이 있다.

|단위명|범위|
|:--|:--|
|니블(Nibble)|4 bit|
|문자(Character)|1 문자 = 1 byte (영어) = 2 byte (한글)|
|워드(Word)|8 / 16 / 32 / 64 bit|

## 진법과 진법 변환
### 진법(Number System)
- 2 진법 : 0 과 1 두가지 기호로 표현하는 수의 체계
- 8 진법 : 0 ~ 7 여덟가지 기호로 표현하는 수의 체계
- 10 진법 : 0 ~ 9 열가지 기호로 표현하는 수의 체계
- 16 진법 : 0 ~ F 열여섯가지 기호로 표현하는 수의 체계

|숫자\\진법|2진수(0~1)<br>Binary|8진수(0~7)<br>Octal|10진수(0~9)<br>Decimal|16진수(0~F)<br>Hexadecimal|
|:--:|:--:|:--:|:--:|:--:|
|**0**|0|0|0|0|
|**1**|1|1|1|1|
|**2**|10|2|2|2|
|**3**|11|3|3|3|
|**4**|100|4|4|4|
|**5**|101|5|5|5|
|**8**|1000|10|8|8|
|**9**|1001|11|9|9|
|**10**|1010|12|10|A|
|**11**|1011|13|11|B|
|**15**|1111|17|15|F|
|**16**|10000|20|16|10|
|**17**|10001|21|17|11|

### 진법의 변환
#### · N 진수를 10 진수로
N 진수 $n_1n_2n_3n_4n_5$ 단, $n_x < N$

$n_1n_2n_3n_4n_5 = n_1 * N^4 + n_2 * N^3 + n_3 * N^2 + n_4 * N^1 + n_5 * N^0$

#### · 8 / 16 진수와 2진수
2진수의 3자리씩 묶으면 8진수, 4자리씩 묶으면 16진수.

8진수의 1자리는 2진수의 3자리, 16진수의 1자리는 2진수의 4자리.

#### · 분수(실수)의 변환
숫자 17.75 를 2진수로 변환

정수부는 그대로 변환 : **10001**

소수부는 2를 곱해가며 정수부를 보고 적는다.

0.75 * 2 = **1**.5 <br>
0.5 * 2 = **1**.0

따라서 소수부는 **11**

결과적으로 분수의 2진수 값은 **10001.11**

하지만 이렇게 정확히 떨어지는 경우는 많지 않기 때문에 일반적으로 숫자를 우절삭 해서 반올림하던가 너무 작은숫자는 띠어낸다.

### 보수(Complement)
컴퓨터에서는 덧셈으로만 연산을 하는데, 더 다양한 연산을 위해 보수가 사용된다.

#### · One's Complement(1의 보수)
N자리의 수에서 최대값(가장 큰 표현형)을 덧셈을 통해 만들어낼 수 있는 두 수.

2자리 10진수를 가정하여 One's Complement 관계를 만족하는 두 수 A, B 가 있다면 다음과 같이 표현할 수 있다.

$A + B = 99$

2진수를 보면 더욱 쉽다. 표현가능한 숫자가 0, 1 두 가지밖에 없기 때문이다.

5자리 2진수를 가정하여 A 가 **10110** 이라고 하면, B 는 이를 뒤집은 **01001** 이 된다. 이 두 수를 더하면 다음과 같다.

$A + B = 11111$

#### · Two's Complement(2의 보수)
Modulus(최대 표현 자리 수)를 덧셈을 통해 만들어낼 수 있는 두 수.

2자리 10진수를 가정하여 Two's Complement 관계를 만족하는 두 수 A, B 가 있다면 다음과 같이 표현할 수 있다.

$A + B = 100$

만약 A 가 41 이라면 각 자리수를 최대로 만드는 값은 58 이다.(41 + 58 = 99)

Two's Complement 는 여기에 1을 더한 값을 뜻한다. 따라서 B 가 A 의 Two's Complement 가 되려면 $B = 58 + 1 = 59$, 즉 59 여야 한다.

이는 단순하게 One's Complement 값에 1을 더한다고 생각하면 된다.

다시 2진법으로 생각해보자. A 가 **10010** 이라고 하면 Two's Complement 를 만족하는 B 는,

A 의 One's Complement 인 01101 에 1 을 더한 **01110** 이 된다.

## 정수 표현
정수형이란, **소숫점이 고정되어있는 수(고정 소숫점, Fixed Point Number)**를 뜻한다.

### 부호화 절대치(Signed Magnitude)
정수의 양수와 음수를 표현하기 위해 정수의 부호와 절대치를 따로 보관하는데, 가장 왼쪽의 bit 를 부호를 표현하는 **sign bit** 로서 사용하고, sign bit 가 0 이면 양수, 1 이면 음수로 사용한다.

따라서 N bit 를 사용하는 2진수의 경우, 표현 범위는 $-(2^{n-1} - 1)$ ~ $(2^{n-1} - 1)$ 이 된다.

분수의 표현같은 컴퓨터의 특성상 딜레마들 중 하나로 +0 과 -0 이 공존한다.

이런 문제를 해결하기 위해 Two's Complement 를 채택하게 되는데, 달라지는 점은 다음과 같다.

4 bit 짜리 2진수 A 가 0000 이라고 가정했을 때, 2의 보수는 $1111 + 1 = 10000$ 이 되는데, 4 bit 로는 똑같이 0000 으로 표현이 되므로, 0 은 무조건 0000 으로 표현이 통일되어 +0 과 -0 이 공존하는 모순을 해결한다.

1의 보수에서 -0 으로 사용되던 1000 은 2의 보수에서 $-2^{n-1}$ 의 음수를 나타내게 되며, 따라서 표현 범위도 N bit 를 사용한다 가정했을 때 $-2^{n-1}$ ~ $(2^{n-1} - 1)$ 이 된다.

4비트 2진수의 값의 2의 보수를 예시로 살펴보자.

|2진수(양수)|2진수(2의 보수)|
|:--:|:--:|
|0000 = 0||
|0001 = 1|1111 = -1|
|0010 = 2|1110 = -2|
|0011 = 3|1101 = -3|
|0100 = 4|1100 = -4|
|0101 = 5|1011 = -5|
|0110 = 6|1010 = -6|
|0111 = 7|1001 = -7|
||1000 = -8|

### Unpacked Decimal(Zoned Decimal)
수치형으로 사용되는 정수는 연산을 위해 위의 방식처럼 2로 나누어서 2진법으로 저장한다. 더 큰 10진수 일수록 자릿수가 많아지고 변환에 따른 연산량이 많아진다.

하지만 연산에 사용하지 않는 비 수치 데이터(Alphanumerical data; 입출력용 데이터)의 경우에는 저장을 위해 이러한 연산을 하는게 불필요한 과정이므로, 다른 표현 방식을 사용한다.

#### 사용 방식
사용 방식은 한 자리의 10진수를 1 Byte 로 표현하는데, 앞의 4 bit 와 뒤의 4 bit 로 나뉜다.

뒤의 4 bit 는 단순히 각 자릿수의 절대치를 나타내는 역할이고, 0 ~ 9 를 표현해야 하므로 4 bit 면 충분한다.

앞의 4 bit 는 **Zoned bit** 와 **Sign bit** 두 가지 역할을 가지는데, 마지막 숫자를 나타낼 때 사용되는 앞의 4 bit 만이 Sign bit 로 사용된다.

**Sign bit** 는 10진수가 양수인지 음수인지 나타내는데, **1100 이면 양수, 1101 이면 음수** 를 나타낸다.

마지막 숫자를 제외한 나머지 숫자를 표현할 때 앞의 4 bit는 단순히 **Zoned bit** 로서 **1111** 의 고정값을 가진다.

**예시) 10진수 173 과 -173 을 표현하는 방법은 다음과 같다.**

![unpacked decimal](/assets/img/captures/1_unpacked_decimal.png){: width='600' .normal }

이러한 형태를 연산에는 사용할 수 없지만 간편하게 입출력에 사용할 수 있다.

IBM 에서 사용되던 EBCDIC 의 숫자 표현과 동일한 방식이다.

### Packed Decimal
Unpacked Decimal 을 연산에 사용하기 위해 Packed Decimal 로 변환하여 사용하기도 한다.

#### 사용 방식
Packed Decimal 의 **Sign bit** 를 맨 뒤로 미룬 후 절대치들만 모두 앞으로 가져와서 사용한다. **Zoned bit** 는 생략한다.

**예시) Unpacked Decimal -173 을 Packed Decimal 로 변환하자.**

![packed decimal](/assets/img/captures/2_packed_decimal.png){: width='600' .normal }

변환된 결과는 연산에는 사용이 가능하지만, 입출력에는 사용이 불가능하다.